<template>
  <div class="root">
    <text class="btn" onclick="done">done</text>

    <!-- 关键：用一个相对定位容器把 pad 和 overlay 叠在一起 -->
    <div class="pad-wrap" if="{{ !showGrid }}">
      <div
        class="pad"
        ontouchstart="onDown"
        ontouchmove="onMove"
        ontouchend="onUp"
        ontouchcancel="onUp"
      ></div>
    </div>
    <div class="grid-wrap" if="{{ showGrid }}">
      <div class="grid-inner">
        <div
          for="{{ (i, cell) in preview }}"
          class="cell {{ cell.on ? 'cell-on' : 'cell-off' }}"
        ></div>
      </div>
    </div>
    <text class="btn" onclick="clear">clear({{ result }})</text>
  </div>
</template>
<style>
.btn {
  font-size: 24px;
  color: #fff;
  background-color: #444;
  padding: 6px;
}
.root {
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.pad-wrap {
  width: 400px;
  height: 400px;
  flex-direction: column;
}

.pad {
  width: 400px;
  height: 400px;
  background-color: #222;
  border-radius: 12px;
}

.grid-wrap {
  width: 400px;
  height: 400px;
  justify-content: center;
  align-items: center;
}

.grid-inner {
  width: 280px;
  height: 280px;
  flex-direction: row;
  flex-wrap: wrap;
}

.cell-off {
  width: 10px;
  height: 10px;
  background-color: #fff;
}

.cell-on {
  width: 10px;
  height: 10px;
  background-color: #000;
}
</style>

<script>
import rawModel from "../../../models/tiny36_14_int8_array.json"
import prompt from "@system.prompt"
import brightness from "@system.brightness"

export default {
  private: {
    // ===== 采集 =====
    N: 28,
    padSize: 400,
    grid: new Uint8Array(28 * 28),
    preview: [],
    showGrid: false,

    drawing: false,
    lastX: 0,
    lastY: 0,

    sampleIntervalMs: 42,
    lastSampleTs: 0,

    brush: 1,

    // ===== 结果 =====
    result: "",
    inferMs: 0, // <-- 保存纯推理耗时（ms）

    // ===== 模型 =====
    model: null,
    layers: null,

    // ===== 推理缓存 =====
    input28: null, // Float32 28*28（镜像后）
    input14: null, // Float32 14*14（由28降采样）
    buf16_14: null, // 16*14*14 (conv1 out)
    buf16_7: null, // 16*7*7   (pool1 out)
    buf32_7: null, // 32*7*7   (conv2 out)
    buf32_3: null, // 32*3*3   (pool2 out, floor)
    buf128: null,
    buf36: null,

    autoMs: 2000, // 3s
    autoTimer: 0, // timeout id
    autoArmed: false, // 已经安排了自动识别
    autoEnabled: true, // 开关
    isInferring: false // 防重入
  },

  onInit() {
    // 有的设备没 brightness，别让它直接把页面搞死
    try {
      brightness.setKeepScreenOn({keepScreenOn: true})
    } catch (e) {}

    const m = rawModel && rawModel.default ? rawModel.default : rawModel
    this.model = m
    const layers = m && m.layers ? m.layers : []
    this.layers = layers

    // ===== 预处理权重：conv2 用 wf；conv1/fc 用 Int16Array w_q + scale =====
    for (let i = 0; i < layers.length; i++) {
      const L = layers[i]
      if (!L) continue

      // bias -> Float32Array
      if ((L.type === "conv2d" || L.type === "fc") && !(L.b instanceof Float32Array)) {
        const bsrc = L.b || []
        const b = new Float32Array(bsrc.length)
        for (let j = 0; j < b.length; j++) b[j] = +bsrc[j]
        L.b = b
      }

      if (L.type === "conv2d") {
        if (L.name === "conv2") {
          // conv2: wf (Float32Array), 然后清 w_q 省内存
          if (!L.wf) {
            const wsrc = L.w_q || []
            const ws = +L.w_scale
            const wf = new Float32Array(wsrc.length)
            for (let j = 0; j < wf.length; j++) wf[j] = (wsrc[j] | 0) * ws
            L.wf = wf
            L.w_q = null
            L.w_scale = 1.0
          }
        } else {
          // conv1: 保留 w_q (Int16Array) + w_scale
          if (!(L.w_q instanceof Int16Array)) {
            const src = L.w_q || []
            const wq = new Int16Array(src.length)
            for (let j = 0; j < wq.length; j++) wq[j] = src[j] | 0
            L.w_q = wq
          }
          L.w_scale = +L.w_scale
        }
      } else if (L.type === "fc") {
        if (!(L.w_q instanceof Int16Array)) {
          const src = L.w_q || []
          const wq = new Int16Array(src.length)
          for (let j = 0; j < wq.length; j++) wq[j] = src[j] | 0
          L.w_q = wq
        }
        L.w_scale = +L.w_scale
        L.inSize = L["in"] | 0
        L.outSize = L["out"] | 0
      }
    }

    // ===== buffers =====
    this.input28 = new Float32Array(28 * 28)
    this.input14 = new Float32Array(14 * 14)

    this.buf16_14 = new Float32Array(16 * 14 * 14)
    this.buf16_7 = new Float32Array(16 * 7 * 7)
    this.buf32_7 = new Float32Array(32 * 7 * 7)
    this.buf32_3 = new Float32Array(32 * 3 * 3)
    this.buf128 = new Float32Array(128)
    this.buf36 = new Float32Array(36)

    console.log("layers ok:", Array.isArray(this.layers), this.layers && this.layers.length)
  },

  onDestroy() {
    try {
      brightness.setKeepScreenOn({keepScreenOn: false})
    } catch (e) {}
  },

  // ============ UI ============
  clear() {
    this.grid.fill(0)
    this.preview = []
    this.showGrid = false
    this.drawing = false
    this.result = ""
    this.inferMs = 0
  },

  onBackPress() {
    if (!this.showGrid) {
      return true
    }
    return false
  },

  done() {
    // 手动 done：先取消自动识别，避免重复触发
    this.cancelAutoInfer()
    if (this.isInferring) return
    if (!this.hasInk()) {
      this.result = ""
      return
    }

    // 预览（你要性能就把这块关掉）
    const arr = []
    for (let i = 0; i < 784; i++) arr.push({on: this.grid[i] ? true : false})
    this.preview = arr
    this.showGrid = true
    prompt.showToast({message: "正在识别..."})

    this.isInferring = true
    const t0 = Date.now()
    const idx = this.infer()
    const ms = Date.now() - t0
    this.inferMs = ms
    const ch = this.idxToChar(idx)
    this.result = ch + "," + ms + "ms"
    this.isInferring = false

    console.log("result:", this.result, "inferMs:", this.inferMs)
  },

  // ============ 采集 ============
  onDown(e) {
    if (this.showGrid) return
    if (!e.changedTouches || !e.changedTouches.length) return

    // 开始写：取消自动识别计时（防止刚落笔就触发）
    this.cancelAutoInfer()

    const t = e.changedTouches[0]
    this.drawing = true
    this.lastX = t.offsetX
    this.lastY = t.offsetY
    this.lastSampleTs = Date.now()
    this.drawPoint(this.lastX, this.lastY)
  },

  onMove(e) {
    if (this.showGrid) return
    if (!this.drawing) return
    if (!e.changedTouches || !e.changedTouches.length) return

    const now = Date.now()
    if (now - this.lastSampleTs < this.sampleIntervalMs) return
    this.lastSampleTs = now

    const t = e.changedTouches[0]
    this.drawLine(this.lastX, this.lastY, t.offsetX, t.offsetY)
    this.lastX = t.offsetX
    this.lastY = t.offsetY

    // 每次有效 move 都重置“停笔 3s 自动识别”
    // 这里先不触发，因为 drawing=true；但会取消旧 timer
    this.cancelAutoInfer()
  },

  onUp() {
    this.drawing = false
    // 抬笔后开始倒计时 3s：如果用户不继续写就自动识别
    this.armAutoInfer()
  },

  drawPoint(x, y) {
    const N = this.N
    const s = N / this.padSize
    const gx = (x * s) | 0
    const gy = (y * s) | 0
    const r = this.brush | 0

    for (let oy = 0; oy < r; oy++) {
      for (let ox = 0; ox < r; ox++) {
        const xx = gx + ox
        const yy = gy + oy
        if (xx >= 0 && xx < N && yy >= 0 && yy < N) {
          this.grid[yy * N + xx] = 255
        }
      }
    }
  },

  drawLine(x0, y0, x1, y1) {
    const dx = Math.abs(x1 - x0)
    const dy = Math.abs(y1 - y0)
    const steps = Math.max(dx, dy) | 0
    if (steps <= 0) {
      this.drawPoint(x0, y0)
      return
    }
    for (let i = 0; i <= steps; i++) {
      const x = x0 + ((x1 - x0) * i) / steps
      const y = y0 + ((y1 - y0) * i) / steps
      this.drawPoint(x, y)
    }
  },

  armAutoInfer() {
    if (!this.autoEnabled) return
    // 有些环境 clearTimeout 对 0 也没事
    if (this.autoTimer) {
      clearTimeout(this.autoTimer)
      this.autoTimer = 0
    }
    this.autoArmed = true
    const self = this
    this.autoTimer = setTimeout(function () {
      self.autoTimer = 0
      if (!self.autoEnabled) return
      if (self.showGrid || self.isInferring || self.drawing) return
      if (!self.hasInk()) return

      self.done() // <-- 自动也做预览+toast+识别
    }, this.autoMs)
  },

  cancelAutoInfer() {
    if (this.autoTimer) {
      clearTimeout(this.autoTimer)
      this.autoTimer = 0
    }
    this.autoArmed = false
  },

  hasInk() {
    // 784 扫一遍很快（比推理小太多）
    const g = this.grid
    for (let i = 0; i < 784; i++) if (g[i]) return true
    return false
  },

  autoDone() {
    // 自动识别：默认不弹 toast、不切预览（省 UI 开销）
    this.isInferring = true
    const t0 = Date.now()
    const idx = this.infer()
    const ms = Date.now() - t0
    this.inferMs = ms
    const ch = this.idxToChar(idx)
    this.result = ch + "," + ms + "ms(auto)"
    this.isInferring = false
  },

  // ============ 预处理：28(镜像) -> 14（2x2 maxpool/OR）===========
  gridTo28FloatMirrored() {
    const out = this.input28
    const g = this.grid
    const N = 28
    for (let y = 0; y < N; y++) {
      const row = y * N
      for (let x = 0; x < N; x++) {
        out[row + x] = g[row + (N - 1 - x)] ? 1.0 : 0.0
      }
    }
    return out
  },

  down28to14_avg(in28, out14) {
    let oi = 0
    for (let y = 0; y < 14; y++) {
      const y2 = y << 1
      const row0 = y2 * 28
      const row1 = (y2 + 1) * 28
      for (let x = 0; x < 14; x++) {
        const x2 = x << 1
        let s = 0
        if (in28[row0 + x2] > 0) s++
        if (in28[row0 + x2 + 1] > 0) s++
        if (in28[row1 + x2] > 0) s++
        if (in28[row1 + x2 + 1] > 0) s++
        // 输出灰度：0,0.25,0.5,0.75,1.0
        out14[oi++] = s * 0.25
      }
    }
    return out14
  },

  // ============ 推理（14x14 模型）===========
  infer() {
    const layers = this.layers
    if (!layers || !layers.length) return 0

    const x28 = this.gridTo28FloatMirrored()
    const x14 = this.down28to14_avg(x28, this.input14)

    // conv1 (1x14x14) -> 16x14x14
    this.conv2d_relu_into_1c(x14, 14, 14, layers[0], this.buf16_14)

    // pool1 -> 16x7x7
    this.maxpool2d_into(this.buf16_14, 16, 14, 14, this.buf16_7)

    // conv2 (16x7x7) -> 32x7x7
    this.conv2_fast_7(this.buf16_7, layers[2], this.buf32_7)

    // pool2 -> 32x3x3（7/2=3 floor）
    this.maxpool2d_into(this.buf32_7, 32, 7, 7, this.buf32_3)

    // fc1+relu (32*3*3=288) -> 128
    this.fc_relu_into(this.buf32_3, layers[4], this.buf128)

    // fc2 (128->36)
    this.fc_into(this.buf128, layers[5], this.buf36)

    // argmax
    const logits = this.buf36
    let best = 0
    let bestv = logits[0]
    for (let i = 1; i < 36; i++) {
      const v = logits[i]
      if (v > bestv) {
        bestv = v
        best = i
      }
    }
    return best
  },

  // ===== conv：1 通道输入，支持 w_q/ws 或 wf =====
  conv2d_relu_into_1c(inputHW, H, W, layer, out) {
    const outC = layer.outC | 0
    const kH = layer.kH | 0
    const kW = layer.kW | 0
    const pad = layer.pad | 0
    const wf = layer.wf
    const wq = layer.w_q
    const ws = layer.w_scale
    const b = layer.b

    const HW = H * W
    const kHW = kH * kW

    for (let oc = 0; oc < outC; oc++) {
      const baseOut = oc * HW
      const baseW = oc * kHW
      const bias = b[oc] || 0.0

      for (let y = 0; y < H; y++) {
        const yW = y * W
        for (let x = 0; x < W; x++) {
          let sum = bias

          for (let ky = 0; ky < kH; ky++) {
            const iy = y + ky - pad
            if (iy < 0 || iy >= H) continue
            const iyW = iy * W
            const wRow = baseW + ky * kW
            for (let kx = 0; kx < kW; kx++) {
              const ix = x + kx - pad
              if (ix < 0 || ix >= W) continue
              const inVal = inputHW[iyW + ix]
              sum += inVal * (wf ? wf[wRow + kx] : wq[wRow + kx] * ws)
            }
          }

          out[baseOut + yW + x] = sum > 0 ? sum : 0
        }
      }
    }
  },

  // ===== conv2 快路径：专用 7x7 / inC=16 / outC=32 / k3 pad1，weights 用 wf =====
  conv2_fast_7(inputCHW, layer, out) {
    const H = 7,
      W = 7,
      HW = 49
    const inC = 16,
      outC = 32
    const wf = layer.wf
    const b = layer.b

    for (let oc = 0; oc < outC; oc++) {
      const outBase = oc * HW
      const bias = b[oc] || 0.0

      // 中间 5x5（y=1..5,x=1..5）
      for (let y = 1; y <= 5; y++) {
        const yW = y * W
        for (let x = 1; x <= 5; x++) {
          let sum = bias

          for (let ic = 0; ic < inC; ic++) {
            const inBase = ic * HW
            const wBase = (oc * inC + ic) * 9

            const p00 = inputCHW[inBase + (yW - W) + (x - 1)]
            const p01 = inputCHW[inBase + (yW - W) + x]
            const p02 = inputCHW[inBase + (yW - W) + (x + 1)]
            const p10 = inputCHW[inBase + yW + (x - 1)]
            const p11 = inputCHW[inBase + yW + x]
            const p12 = inputCHW[inBase + yW + (x + 1)]
            const p20 = inputCHW[inBase + (yW + W) + (x - 1)]
            const p21 = inputCHW[inBase + (yW + W) + x]
            const p22 = inputCHW[inBase + (yW + W) + (x + 1)]

            sum += p00 * wf[wBase + 0]
            sum += p01 * wf[wBase + 1]
            sum += p02 * wf[wBase + 2]
            sum += p10 * wf[wBase + 3]
            sum += p11 * wf[wBase + 4]
            sum += p12 * wf[wBase + 5]
            sum += p20 * wf[wBase + 6]
            sum += p21 * wf[wBase + 7]
            sum += p22 * wf[wBase + 8]
          }

          out[outBase + yW + x] = sum > 0 ? sum : 0
        }
      }

      // 边界点慢算（只占少量）
      for (let x = 0; x < W; x++) {
        out[outBase + 0 * W + x] = this.conv2_edge_point_7(inputCHW, wf, bias, oc, x, 0)
        out[outBase + 6 * W + x] = this.conv2_edge_point_7(inputCHW, wf, bias, oc, x, 6)
      }
      for (let y = 1; y <= 5; y++) {
        out[outBase + y * W + 0] = this.conv2_edge_point_7(inputCHW, wf, bias, oc, 0, y)
        out[outBase + y * W + 6] = this.conv2_edge_point_7(inputCHW, wf, bias, oc, 6, y)
      }
    }
  },

  conv2_edge_point_7(inputCHW, wf, bias, oc, x, y) {
    const H = 7,
      W = 7,
      HW = 49
    const inC = 16
    let sum = bias

    for (let ic = 0; ic < inC; ic++) {
      const inBase = ic * HW
      const wBase = (oc * inC + ic) * 9

      for (let ky = -1; ky <= 1; ky++) {
        const iy = y + ky
        if (iy < 0 || iy >= H) continue
        const iyW = iy * W
        const kRow = (ky + 1) * 3
        for (let kx = -1; kx <= 1; kx++) {
          const ix = x + kx
          if (ix < 0 || ix >= W) continue
          sum += inputCHW[inBase + iyW + ix] * wf[wBase + kRow + (kx + 1)]
        }
      }
    }
    return sum > 0 ? sum : 0
  },

  // ===== pool：写入 out（支持 7->3 floor）=====
  maxpool2d_into(inputCHW, C, H, W, out) {
    const outH = H >> 1
    const outW = W >> 1
    const inHW = H * W
    const outHW = outH * outW

    for (let c = 0; c < C; c++) {
      const inBase = c * inHW
      const outBase = c * outHW

      for (let y = 0; y < outH; y++) {
        const y2 = y << 1
        const row0 = y2 * W
        const row1 = (y2 + 1) * W
        const oy = y * outW

        for (let x = 0; x < outW; x++) {
          const x2 = x << 1

          let m = inputCHW[inBase + row0 + x2]
          let v = inputCHW[inBase + row0 + x2 + 1]
          if (v > m) m = v
          v = inputCHW[inBase + row1 + x2]
          if (v > m) m = v
          v = inputCHW[inBase + row1 + x2 + 1]
          if (v > m) m = v

          out[outBase + oy + x] = m
        }
      }
    }
  },

  // ===== fc：写入 out buffer =====
  fc_into(input, layer, out) {
    const inSize = layer.inSize | 0
    const outSize = layer.outSize | 0
    const wq = layer.w_q
    const ws = layer.w_scale
    const b = layer.b

    for (let o = 0; o < outSize; o++) {
      let sum = b[o] || 0.0
      const baseW = o * inSize
      for (let i = 0; i < inSize; i++) sum += input[i] * (wq[baseW + i] * ws)
      out[o] = sum
    }
  },

  fc_relu_into(input, layer, out) {
    this.fc_into(input, layer, out)
    for (let i = 0; i < out.length; i++) {
      const v = out[i]
      out[i] = v > 0 ? v : 0
    }
  },

  idxToChar(idx) {
    idx = idx | 0
    if (idx < 10) return String.fromCharCode(48 + idx)
    return String.fromCharCode(97 + (idx - 10))
  }
}
</script>
